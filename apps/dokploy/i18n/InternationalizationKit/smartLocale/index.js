import fs from "node:fs";
import path from "node:path";

/**
 * A Webpack plugin to generate type definitions and import statements
 * for localization files.
 */
class SmartLocalePlugin {
	/**
	 * @param {Object} options - Options for the plugin.
	 * @param {string} options.inputDirectory - The directory containing input localization files.
	 * @param {string} options.outputDirectory - The directory where type definition files will be written.
	 * @param {string} options.outputImportDirectory - The directory for import statements.
	 * @param {string} options.defaultLocale - The default locale to be used.
	 * @param {string} options.fileType - The file type of localization files (e.g., json).
	 */
	constructor({
		inputDirectory,
		outputDirectory,
		outputImportDirectory,
		defaultLocale,
		fileType,
	}) {
		this.inputDirectory = inputDirectory;
		this.outputDirectory = outputDirectory;
		this.outputImportDirectory = outputImportDirectory;
		this.defaultLocale = defaultLocale;
		this.fileType = fileType;
		this.name = "smart-locale";
		this.hasRun = false; // 添加一个标志来确保只运行一次
	}

	/**
	 * Applies the plugin to the Webpack compiler.
	 * @param {import('copy-webpack-plugin').Compiler} compiler - The Webpack compiler instance.
	 */
	apply(compiler) {
		compiler.hooks.emit.tapAsync(this.name, (compilation, callback) => {
			if (!this.hasRun) {
				try {
					this.generateLocalesTypes();
					this.hasRun = true; // 标志设置为 true，确保后续不会重复执行
				} catch (error) {
					console.error("Error generating locales:", error);
				}
			}
			callback();
		});
	}

	/**
	 * Generates type definitions for the localization keys.
	 */
	generateLocalesTypes() {
		const localeRawData = fs.readFileSync(
			`${this.inputDirectory}${this.defaultLocale}.${this.fileType}`,
			"utf-8",
		);
		const localeData = JSON.parse(localeRawData);

		if (!fs.existsSync(this.outputDirectory)) {
			fs.mkdirSync(this.outputDirectory, { recursive: true });
		}

		const localesKeys = new Set();
		const directory = fs.readdirSync(this.inputDirectory);

		for (const file of directory) {
			if (file.endsWith(`.${this.fileType}`)) {
				const rawData = fs.readFileSync(
					`${this.inputDirectory}${file}`,
					"utf-8",
				);
				const jsonData = JSON.parse(rawData);
				const keys = Object.keys(jsonData);

				for (const key of keys) {
					localesKeys.add(key);
				}
			}
		}

		let typeDefinitions = "/* Autogenerated file. Do not edit manually. */\n\n";
		typeDefinitions += "interface Locales {\n";

		for (const key of localesKeys) {
			const text = localeData[key] || "";
			typeDefinitions += `\t/**\n\t * ${text}\n\t */\n\t"${key}": string;\n`;
		}

		typeDefinitions += "}\n\n";
		typeDefinitions += "export default Locales;\n";

		const outputPath = path.join(this.outputDirectory, "locales.d.ts");
		fs.writeFileSync(outputPath, typeDefinitions);

		this.generateImportStatements();
	}

	/**
	 * Generates import statements for the localization files.
	 */
	generateImportStatements() {
		/**
		 * @type {string[]}
		 */
		const importStatements = [];
		/**
		 * @type {string[]}
		 */
		const localeMappings = [];

		const directory = fs.readdirSync(this.inputDirectory);

		for (const file of directory) {
			if (file.endsWith(`.${this.fileType}`)) {
				const localeName = file
					.replace(`.${this.fileType}`, "")
					.replace(/-/g, "_");
				const relativePath = `./${path.relative(this.outputImportDirectory, path.join(this.inputDirectory, file)).replace(/\\/g, "/")}`;
				importStatements.push(`import ${localeName} from "${relativePath}";`);
				localeMappings.push(
					`\t"${localeName.replace(/_/g, "-")}": ${localeName}`,
				);
			}
		}

		let importFileContent =
			"/* Autogenerated file. Do not edit manually. */\n\n";
		importFileContent += `${importStatements.join("\n")}\n\n`;
		importFileContent += `const locales = {\n${localeMappings.join(",\n")},\n};\n\n`;
		importFileContent += "export default locales;\n";

		const outputPath = path.join(
			this.outputImportDirectory,
			"locales-imports.ts",
		);
		fs.writeFileSync(outputPath, importFileContent, { encoding: "utf-8" });
	}
}

export default SmartLocalePlugin;
